import { get as get$1, writable as writable$1 } from 'svelte/store';
import { noop, run_all, is_function } from 'svelte/internal';

function isSimpleDeriver(deriver) {
    return deriver.length < 2;
}
function generator(storage) {
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param key storage key
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(key, value, start) {
        return {
            subscribe: writable(key, value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param key storage key
     * @param {*=}value default value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(key, value, start = noop) {
        function wrap_start(ogSet) {
            return start(function wrap_set(new_value) {
                if (storage) {
                    storage.setItem(key, JSON.stringify(new_value));
                }
                return ogSet(new_value);
            });
        }
        if (storage) {
            if (storage.getItem(key)) {
                value = JSON.parse(storage.getItem(key));
            }
            storage.setItem(key, JSON.stringify(value));
        }
        const ogStore = writable$1(value, start ? wrap_start : undefined);
        function set(new_value) {
            if (storage) {
                storage.setItem(key, JSON.stringify(new_value));
            }
            ogStore.set(new_value);
        }
        function update(fn) {
            set(fn(get$1(ogStore)));
        }
        function subscribe(run, invalidate = noop) {
            return ogStore.subscribe(run, invalidate);
        }
        return { set, update, subscribe };
    }
    /**
     * Derived value store by synchronizing one or more readable stores and
     * applying an aggregation function over its input values.
     * @param key storage key
     * @param {Stores} stores input stores
     * @param {function(Stores=, function(*)=):*}fn function callback that aggregates the values
     * @param {*=}initial_value when used asynchronously
     */
    function derived(key, stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        if (storage && storage.getItem(key)) {
            initial_value = JSON.parse(storage.getItem(key));
        }
        return readable(key, initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const input = single ? values[0] : values;
                if (isSimpleDeriver(fn)) {
                    set(fn(input));
                }
                else {
                    const result = fn(input, set);
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }
    return {
        readable,
        writable,
        derived,
        get: get$1
    };
}

const storage = typeof window !== 'undefined' ? window.sessionStorage : undefined;
const { readable, writable, derived, get } = generator(storage);

export { derived, get, readable, writable };
